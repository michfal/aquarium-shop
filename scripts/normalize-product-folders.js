import 'dotenv/config';
import { createClient } from '@supabase/supabase-js';

/**
 * ENV:
 *  - VITE_SUBABASE_URL (Twoja nazwa)   // fallback: VITE_SUPABASE_URL
 *  - SUPABASE_SERVICE_ROLE_KEY         // klucz serwisowy (wymagany do move/remove)
 *  - BUCKET_NAME (opcjonalnie, domy≈õlnie 'product-images')
 *  - DRY_RUN=1 (opcjonalnie: tylko loguje, nic nie zmienia)
 */
const SUPA_URL = process.env.VITE_SUBABASE_URL || process.env.VITE_SUPABASE_URL || '';

const SERVICE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY || '';
const BUCKET = process.env.BUCKET_NAME || 'product-images';
const DRY_RUN = process.env.DRY_RUN === '1';

if (!SUPA_URL || !SERVICE_KEY) {
  console.error('‚ùå Brak VITE_SUBABASE_URL/VITE_SUPABASE_URL lub SUPABASE_SERVICE_ROLE_KEY w .env');
  process.exit(1);
}

const supabase = createClient(SUPA_URL, SERVICE_KEY);

const IMG_EXT = ['.png', '.jpg', '.jpeg', '.webp', '.gif', '.avif'];

function extLower(name) {
  const i = name.lastIndexOf('.');
  return i >= 0 ? name.slice(i).toLowerCase() : '';
}
function isImage(name) {
  return IMG_EXT.includes(extLower(name));
}
function isMainName(name) {
  return /^main\.(png|jpe?g|webp|gif|avif)$/i.test(name);
}

async function listRoot() {
  const { data, error } = await supabase.storage.from(BUCKET).list('', { limit: 1000 });
  if (error) throw error;
  return data ?? [];
}

async function listPrefix(prefix) {
  const { data, error } = await supabase.storage.from(BUCKET).list(prefix, { limit: 1000 });
  if (error) return { files: null, error };
  return { files: data ?? [], error: null };
}

/**
 * Heurystyka wyboru kandydata na nowe main:
 * - bierzemy pierwszy ‚Äûnie-main‚Äù plik graficzny (posortowane alfabetycznie dla deterministyczno≈õci)
 */
function pickCandidate(otherImages) {
  if (!otherImages || otherImages.length === 0) return null;
  const sorted = [...otherImages].sort((a, b) => a.name.localeCompare(b.name));
  return sorted[0];
}

async function ensureMainAndClean(prefix, entries) {
  const keep = entries.find((f) => f.name === '.keep');
  const images = entries.filter((f) => !f.name.endsWith('/') && isImage(f.name));

  if (images.length === 0) {
    console.log(`  ‚Ä¢ brak obrazk√≥w ‚Äî .keep zostaje`);
    return;
  }

  const mainImages = images.filter((f) => isMainName(f.name));
  const otherImages = images.filter((f) => !isMainName(f.name));
  const hasMain = mainImages.length > 0;

  // 1) Je≈õli jest main AND jest inny obraz ‚Äî usu≈Ñ main, potem przemianuj inny na main.<ext>
  if (hasMain && otherImages.length > 0) {
    const currentMain = mainImages[0]; // je≈õli jest wiƒôcej ni≈º jeden, bierzemy pierwszy
    const candidate = pickCandidate(otherImages);
    const candidateExt = extLower(candidate.name);
    const currentMainPath = `${prefix}${currentMain.name}`;
    const candidatePath = `${prefix}${candidate.name}`;
    const newMainPath = `${prefix}main${candidateExt}`;

    console.log(
      `  ‚Üª replace main: usuwam ${currentMainPath}, a potem ${candidatePath} ‚Üí ${newMainPath}`,
    );

    if (!DRY_RUN) {
      // a) Usu≈Ñ istniejƒÖcy main.<ext>
      const del = await supabase.storage.from(BUCKET).remove([currentMainPath]);
      if (del?.error) {
        console.warn(`  ‚ö†Ô∏è remove main error: ${del.error.message}`);
      }

      // b) Przenie≈õ wybrany obraz jako nowy main.<ext>
      let mv = await supabase.storage.from(BUCKET).move(candidatePath, newMainPath);
      if (mv.error) {
        // na wszelki wypadek spr√≥buj usunƒÖƒá cel i ponowiƒá (np. gdy istnia≈Ç plik z tym samym rozszerzeniem)
        await supabase.storage.from(BUCKET).remove([newMainPath]);
        mv = await supabase.storage.from(BUCKET).move(candidatePath, newMainPath);
        if (mv.error) {
          console.warn(`  ‚ö†Ô∏è move candidate‚Üímain error: ${mv.error.message}`);
        }
      }
    }
  }

  // 2) Je≈õli nie ma w og√≥le main ‚Äî zr√≥b main z pierwszego dostƒôpnego
  else if (!hasMain && otherImages.length > 0) {
    const candidate = pickCandidate(otherImages);
    const candidateExt = extLower(candidate.name);
    const src = `${prefix}${candidate.name}`;
    const dst = `${prefix}main${candidateExt}`;
    console.log(`  ‚Üí create main: ${src}  ->  ${dst}`);
    if (!DRY_RUN) {
      let mv = await supabase.storage.from(BUCKET).move(src, dst);
      if (mv.error) {
        await supabase.storage.from(BUCKET).remove([dst]);
        mv = await supabase.storage.from(BUCKET).move(src, dst);
        if (mv.error) {
          console.warn(`  ‚ö†Ô∏è move error: ${mv.error.message}`);
        }
      }
    }
  } else {
    // hasMain && otherImages.length === 0
    console.log(`  ‚Ä¢ tylko main.* ‚Äî bez zmian`);
  }

  // 3) Usu≈Ñ .keep, je≈õli istnieje i folder ma ju≈º obrazki
  if (keep) {
    const keepPath = `${prefix}.keep`;
    console.log(`  ‚úÇ delete: ${keepPath}`);
    if (!DRY_RUN) {
      const { error } = await supabase.storage.from(BUCKET).remove([keepPath]);
      if (error) console.warn(`  ‚ö†Ô∏è remove .keep error: ${error.message}`);
    }
  }
}

async function main() {
  console.log(`Bucket: ${BUCKET} | dryRun=${DRY_RUN ? 'YES' : 'NO'}`);

  let roots;
  try {
    roots = await listRoot();
  } catch (e) {
    console.error('‚ùå list root error:', e);
    process.exit(1);
  }

  for (const entry of roots) {
    const name = entry.name;
    if (!name || name === 'tmp' || name.startsWith('.')) continue;

    const prefix = `${name}/`;
    const { files, error } = await listPrefix(prefix);
    if (error) continue;
    if (!files || files.length === 0) {
      console.log(`‚Ä¢ ${prefix} (pusto) ‚Äî nic do zmiany`);
      continue;
    }

    console.log(`\nüìÅ ${prefix}`);
    const childFiles = files.filter((f) => !f.name.endsWith('/'));
    await ensureMainAndClean(prefix, childFiles);
  }

  console.log('\n‚úÖ Done');
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
